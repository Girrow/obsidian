### <mark class='blue'> 17장 경계: 선 긋기</mark>

소프트웨어 아키텍처는 선을 긋는 기술이며, 나는 이러한 선을 경계(boundary)라고 부른다. 경계는 
* 소프트웨어 요소를 서로 분리
* 경계 한편에 있는 요소가 반대편에 있는 요소를 알지 못하도록 막음 
* 핵심적인 업무 로직을 오염시키지 못하게 만들려는 목적

아키텍트의 목표는 필요한 시스템을 만들고 유지하는 데 드는 인적 자원을 최소화하는 것이라는 사실을 상기하자. 시스템의 업무 요구사항, 즉 유스케이스와 아무런 관련이 없는 결정이다. 좋은 시스템의 아키텍처란 이러한 결정이 부수적이며, 결정을 연기할 수 있는 아키텍처다. 이러한 결정을 가능한 한 최후의 순간에 내릴 수 있게 해주며, 결정에 따른 영향이 크지 않게 만든다.

##### <mark>[두 가지 슬픈 이야기\]</mark>

#Fitness

자그마치 18개월이라는 기간 동안 운영할 데이터베이스가 없다는 사실은 스키마와 관련된 문제들, 쿼리 문제들, 데이터베이스 서버 문제들, 패스워드 문제들, 접속 시간과 관련된 문제들, 그리고 데이터베이스를 작동시킬 때 추하게 고개를 드는 여타 모든 고약한 문제가 없엇다는 사실을 뜻한다. 또한 테스트를 느리게 만드는 데이터베이스가 없으니 테스트를 더 빨리 돌릴 수 있다는 뜻이기도 하다. 간단히 말해서 경계선을 긋는 행위는 결정을 늦추고 연기하는 데 도움이 되었고, 궁극적으로는 시간을 엄청나게 절약해주었으며, 골치를 썩지 않게 해주었다. 이것이 바로 좋은 아키텍처라면 반드시 해야 하는 일이다.

#어떻게_선을_그을까_그리고_언제_그을까

관련이 있는 것과 없는 것 사이에 선을 긋는다.

업무 규칙은 스키마, 쿼리 언어, 또는 데이터베이스와 관련된 나머지 세부사항에 대해 어떤 것도 알아서는 안된다. 업무 규칙이 알아야 할 것은 데이터를 가져오고 저장할 때 사용할 수 있는 함수 집합이 있다는 사실이 전부다.

데이터베이스는 오라클, MySQL 등으로 구현할 수 있고, 심지어 플랫 파일로도 구현할 수 있다. 업무 규칙은 전혀 개의치 않는다. 그리고 이 같은 사실은 데이터베이스에 대한 결정은 연기할 수 있으며, 데이터베이스를 결정하기에 앞서 업무 규칙을 먼저 작성하고 테스트하는 데 집중할 수 있음을 의미한다.

#입력과_출력은

입력과 출력은 중요하지 않다는 사실이다.

사용자 경험은 인터페이스에 의해 좌우된다. 화면, 마우스, 버튼, 음향이 바로 그 인터페이스다. 이러한 인터페이스 뒤에는 인터페이스를 조작하는 모델(데이터 구조와 함수로 구성된 정교한 집합)이 존재한다는 사실을 잊어버린다. 인터페이스는 모델에게 있어 중요하지 않다. 중요한 것은 업무 규칙이다.

#플러그인_아키텍처

소프트웨어 개발 기술의 역사는 플러그인을 손쉽게 생성하여, 확장 가능하며 유지보수가 쉬운 시스템 아키텍처를 확립할 수 있게 만드는 방법에 대한 이야기다. 선택적이거나 또는 수많은 다양한 형태로 구현될 수 있는 나머지 컴포넌트로부터 핵심적인 업무 규칙은 분리되어 있고, 또한 독립적이다.

#플러그인에_대한_논의

우리는 특정 모듈이 나머지 모듈에 영향받지 않기를 바란다. 시스템에서 한 부분이 변경되더라도 관련 없는 나머지 부분이 망가지길 원치 않는다. 개발 중인 시스템에서 이러한 종류의 취약성이 드러나지 않기를 바란다. 시스템을 플러그인 아키텍처로 배치함으로써 변경이 전파될 수 없는 방화벽을 생성할 수 있다. GUI가 업무 규칙에 플러그인 형태로 연결되면 GUI에서 발생한 변경은 절대로 업무 규칙에 영향을 미칠 수 없다. 경계는 변경의 축(axis of change)이 있는 지점에 그어진다. 경계의 한쪽에 위치한 컴포넌트는 경계 반대편의 컴포넌트와는 다른 속도로, 그리고 다른 이유로 변경된다. 단일 책임 원칙은 어디에 경계를 그어야 할지를 알려준다.

#### [결론]

소프트웨어 아키텍처에서 경계선을 그리려면 먼저 시스템을 컴포넌트 단위로 분할해야 한다. 일부 컴포넌트는 핵심 업무 규칙에 해당한다. 나머지 컴포넌트는 플러그인으로, 핵심 업무와는 직접적인 관련이 없지만 필수 기능을 포함한다. 그런 다음 컴포넌트 사이의 화살표가 핵심 업무를 향하도록 이들 컴포넌트의 소스를 배치한다. 의존성 화살표는 저수준 세부사항에서 고수준의 추상화를 향하도록 배치된다.